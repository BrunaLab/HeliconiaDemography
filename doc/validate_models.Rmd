---
title: "Model validation plots"
author: "Eric R. Scott"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
## target knits Rmds in their own session, so load libraries here.
library(targets)
library(statmod)
library(tidyverse)
library(gratia)
library(mgcv)
library(dlnm)
```

# TODO

- increase knots for some models (https://github.com/BrunaLab/HeliconiaDemography/issues/92)
- check diagnostics for individual-level random effects.  Doesn't look good, but not sure how to interpret or what to do. 


# Analysis

## Survival

Quantile residuals are more appropriate for binomial models.

### Fragments

```{r}
withr::with_dir(here::here(),{
  tar_load(c(s_1ha, s_cf, s_cf_sub))
})
```

```{r}
summary(s_1ha)
```

```{r}
draw(s_1ha)
```

```{r echo=TRUE}
s_1ha_res <- qresid(s_1ha)
par(mfrow = c(2,2))
#histogram
plot(density(s_1ha_res))
#QQ plot
qqnorm(s_1ha_res); qqline(s_1ha_res)
#Fitted vs. residuals
scatter.smooth(predict(s_1ha, type = "response"), s_1ha_res, col = "grey")
```
```{r}
# gam.check(s_1ha)
```

Basis dimension checking with `gam.check()` doesn't appear to work for `dlnm` crossbasis smooths. Instead I'll use a method from `?choose.k` to check for adequate knots.  Unfortunately, `bs = "cs"` doesn't work with `dlnm`, so I'll use `select = TRUE` instead to reduce chance of overfitting.

```{r}
# looking for near zero edf
gam(s_1ha_res ~ s(log_size_prev, k = 10, bs = "cs"), gamma = 1.4,
    data = model.frame(s_1ha)) #fine

gam(s_1ha_res ~ s(spei_history, L,
      bs = "cb",
      k = c(3, 35),
      xt = list(bs = "cr")),
    gamma = 1.4,
    select = TRUE,
    data = model.frame(s_1ha)) #fine
```


### Continuous Forest

```{r}
summary(s_cf)
```

```{r}
draw(s_cf)
```

```{r echo=TRUE}
s_cf_res <- qresid(s_cf)
par(mfrow = c(2,2))
#histogram
plot(density(s_cf_res))
#QQ plot
qqnorm(s_cf_res); qqline(s_cf_res)
#Fitted vs. residuals
scatter.smooth(predict(s_cf, type = "response"), s_cf_res, col = "grey")
```

```{r}
# looking for near zero edf
gam(s_cf_res ~ s(log_size_prev, k = 10, bs = "cs"), gamma = 1.4,
    data = model.frame(s_cf)) #fine

gam(s_cf_res ~ s(spei_history, L,
      bs = "cb",
      k = c(3, 35),
      xt = list(bs = "cr")),
    gamma = 1.4,
    select = TRUE,
    data = model.frame(s_cf)) 
```



### Continuous forest subsample

To check that differences are not purely due to sample size differences, particularly that lower edf in continuous forests is due to higher sample size.  For survival, edf is actually higher in CF with a larger sample size.  With subsample, edf are more similar.

```{r}
summary(s_1ha)$edf[3]
summary(s_cf)$edf[3]
summary(s_cf_sub)$edf[3]
```


```{r}
draw(s_cf_sub)
```
Surface still looks different in a similar way though.

```{r}
rm(s_1ha, s_cf, s_cf_sub)
```

## Growth

```{r}
withr::with_dir(here::here(),{
  tar_load(c(g_1ha, g_cf, g_cf_sub))
})
```

### Fragments

```{r}
summary(g_1ha)
```

```{r}
draw(g_1ha)
```

```{r}
appraise(g_1ha)
```
```{r}
g_1ha_res <- residuals(g_1ha)
# looking for near zero edf
gam(g_1ha_res ~ s(log_size_prev, k = 10, bs = "cs"), gamma = 1.4,
    data = model.frame(g_1ha)) #fine

gam(g_1ha_res ~ s(spei_history, L,
      bs = "cb",
      k = c(3, 35),
      xt = list(bs = "cr")),
    gamma = 1.4,
    select = TRUE,
    data = model.frame(g_1ha)) #fine
```

### Continuous Forest

```{r}
summary(g_cf)
```

```{r}
draw(g_cf)
```

```{r}
gratia::appraise(g_cf)
```

```{r}
g_cf_res <- residuals(g_cf)
# looking for near zero edf
gam(g_cf_res ~ s(log_size_prev, k = 10, bs = "cs"), gamma = 1.4,
    data = model.frame(g_cf)) #fine

gam(g_cf_res ~ s(spei_history, L,
      bs = "cb",
      k = c(3, 35),
      xt = list(bs = "cr")),
    gamma = 1.4,
    select = TRUE,
    data = model.frame(g_cf)) #fine
```

### Continuous Forest subsample

To check that differences are not purely due to sample size differences, particularly that lower edf in continuous forests is due to higher sample size.

```{r}
summary(g_1ha)$edf[3]
summary(g_cf)$edf[3]
summary(g_cf_sub)$edf[3]
```
edf of subsample is similar to full dataset, despite differences in sample size.

```{r}
draw(g_cf_sub)
```
Crossbasis surface looks nearly identical.

```{r}
rm(g_1ha, g_cf, g_cf_sub)
```

## Flowering

Quantile residuals are more appropriate for binomial models.

```{r}
withr::with_dir(here::here(),{
  tar_load(c(f_1ha, f_cf, f_cf_sub))
})
```

### Fragments

```{r}
summary(f_1ha)
```

```{r}
draw(f_1ha)
```

```{r}
f_1ha_res <- qresid(f_1ha)
par(mfrow = c(2,2))
#histogram
plot(density(f_1ha_res))
#QQ plot
qqnorm(f_1ha_res); qqline(f_1ha_res)
#Fitted vs. residuals
scatter.smooth(predict(f_1ha, type = "response"), f_1ha_res, col = "grey")
```

```{r}
# looking for near zero edf
gam(f_1ha_res ~ s(log_size_prev, k = 10, bs = "cs"), gamma = 1.4,
    data = model.frame(f_1ha)) #fine

gam(f_1ha_res ~ s(spei_history, L,
      bs = "cb",
      k = c(3, 35),
      xt = list(bs = "cr")),
    gamma = 1.4,
    select = TRUE,
    data = model.frame(f_1ha)) #fine
```

### Continuous Forest

```{r}
summary(f_cf)
```

```{r}
draw(f_cf)
```

```{r}
f_cf_res <- qresid(f_cf)
par(mfrow = c(2,2))
#histogram
plot(density(f_cf_res))
#QQ plot
qqnorm(f_cf_res); qqline(f_cf_res)
#Fitted vs. residuals
scatter.smooth(predict(f_cf, type = "response"), f_cf_res, col = "grey")
```

```{r}
# looking for near zero edf
gam(f_cf_res ~ s(log_size_prev, k = 10, bs = "cs"), gamma = 1.4,
    data = model.frame(f_cf)) #fine

gam(f_cf_res ~ s(spei_history, L,
      bs = "cb",
      k = c(3, 35),
      xt = list(bs = "cr")),
    gamma = 1.4,
    select = TRUE,
    data = model.frame(f_cf)) #fine
```

### Continuous Forest subsample

To check that differences are not purely due to sample size differences, particularly that lower edf in continuous forests is due to higher sample size.  For flowering, edf is actually slightly higher in CF with a larger sample size.  With subsample, edf are more similar.

```{r}
summary(f_1ha)$edf[3]
summary(f_cf)$edf[3]
summary(f_cf_sub)$edf[3]
```

```{r}
draw(f_cf_sub)
```
Crossbasis surface looks extremely similar.

### Flowering prob of largest plants

Figure out flowering probability of largest quartile of plants in each habitat

```{r}
newdf_cf <-
  f_cf$model %>% #use model data frame
  mutate(quartiles = ntile(log_size_prev, 4)) %>% 
  filter(quartiles == 4)

newdf_1ha <-
  f_1ha$model %>% 
  mutate(quartiles = ntile(log_size_prev, 4)) %>% 
  filter(quartiles == 4)
```


```{r}
#equivalent to flowering once every __ years
1/predict(f_cf, newdata = newdf_cf) %>% mean() %>% plogis()
1/predict(f_1ha, newdata = newdf_1ha) %>% mean() %>% plogis()
```


```{r}
rm(f_1ha, f_cf, f_cf_sub)
```

# Reproducibility

<details>

<summary>

Reproducibility receipt

</summary>

```{r}
## datetime
Sys.time()

## repository
if(requireNamespace('git2r', quietly = TRUE)) {
  git2r::repository()
} else {
  c(
    system2("git", args = c("log", "--name-status", "-1"), stdout = TRUE),
    system2("git", args = c("remote", "-v"), stdout = TRUE)
  )
}

## session info
sessionInfo()
```

</details>
