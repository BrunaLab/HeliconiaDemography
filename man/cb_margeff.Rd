% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/crossbasis.R
\name{cb_margeff}
\alias{cb_margeff}
\title{Calculate marginal effects of a crossbasis smooth}
\usage{
cb_margeff(Q, L, model, ref_data = NULL, meshpts = c(50, 50), calc_dist = TRUE)
}
\arguments{
\item{Q}{The matrix of predictor values used to generate a crossbasis smooth}

\item{L}{The matrix of lags used to generate a crossbasis smooth}

\item{model}{a gam with a crossbasis smooth}

\item{ref_data}{reference data passed to the \code{newdata} argument of \code{predict}
(optional). This one-row data frame should contain values for all model
terms \strong{except} \code{Q} and \code{L}.}

\item{meshpts}{vector of length 2; The number of meshpoints for values of Q
and L, respectively, to use to generate fitted values}

\item{calc_dist}{logical; Calculate distance between predicted values and
actual data points?  This is inspired by the \code{too.far} argument of
\code{plot.gam()}.  If \code{TRUE} (default), it adds the column \code{min_dist} which is
useful for filtering data before plotting because "smooths tend to go wild
away from data". This step takes a long time, so if you don't need it,
consider setting to \code{FALSE}}
}
\value{
a tibble suitable for plotting marginal effects as a heatmap or
contour plot.  \code{x} is the meshpoint values across the range of the
predictor, \code{Q}; \code{lag} is the values of \code{L}; \code{fitted} and \code{se.fit} are the
results of \code{predict.gam()}; min_dist is the euclidean distance on the unit
square from the fitted values to the actual data used to fit the model.
}
\description{
Calculate marginal effects of a crossbasis smooth created with the \code{cb} basis
from the \code{dlnm} package in a model created with \code{gam()}. Everything is kept
average (or at reference value for factors) and response values are predicted
using the range of values of Q at each lag defined by L.
}
\examples{
\dontrun{
library(dlnm)
library(mgcv)
library(tsModel)
data("chicagoNMMAPS")
Q <- Lag(chicagoNMMAPS$temp, 0:25) #temperature data, lagged
L <- matrix(0:25,nrow(Q),ncol(Q),byrow=TRUE) #matrix of 0-25
# Fit DLNM model
gam1 <- gam(death ~ s(Q, L, bs="cb", k=10) + s(pm10) + dow,
            family=quasipoisson(), 
            data = chicagoNMMAPS,
            method='REML')
# Calculate marginal effect of lagged temperature, all else being held average.
cb_margeff(Q, L, gam1)
}
}
