---
title: "Density dependence"
author: "Eric R. Scott"
date: "2020-09-13"
output: 
  html_notebook: 
    highlight: kate
    theme: yeti
    toc: yes
    toc_float: yes
    number_sections: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(here)
library(conflicted)
library(lme4)
library(bbmle)
library(car)
library(broom)
library(broom.mixed)
library(patchwork)
library(performance)

conflict_prefer("lag", "dplyr")
conflict_prefer("filter", "dplyr")
conflict_prefer("select", "dplyr")
```

*Last compiled: `r Sys.Date()`*

# TODO

- Get confidence intervals for cross-basis predictions.  Plot slices with confidence bands.
- Try with just Florestal (really huge plants there)

# Purpose

Start by looking for density dependence on growth, survival, and reproduction in continuous forests using the number of plants in the same grid-cell as a metric for density.

# Load Data

```{r data, echo=TRUE}
ha <- read_rds(here("analysis", "data", "derived_data", "ha_density.rds"))
ha
```
This is the main *Heliconia* dataset, but with densities of conspecifics (shoots/m^2^) at different rings with inner and outer radii in meters.  So, for example, the `shts_8_8.5` column is the number of *Heliconia* shoots/m^2^ in a ring 8 to 8.5 m around the focal plant.

The `x` and `y` coordinates are averages of data from 2006, 2007, and 2009, but joined to the full range of the dataset--assuming that plants don't move.

## Tidying and subsetting

```{r}
ha <-
  ha %>%
  ungroup() %>% 
  arrange(ha_id_number, year) %>% 
  #scale year, and convert to factor since I'll be using as random effect
  mutate(year_post = as_factor(year - min(year)),
         log_shts = log(shts),
         log_shts_next = log(shts_next),
         habitat = as.factor(habitat),
         ha_id_number = as.factor(ha_id_number),
         plot = as.factor(plot))
```

Emilio suggested starting with a couple of small subsets of data to make sure I'm getting things right.  

1. Just continuous forest
2. Just a single plot (e.g. 5750)
3. Just plants with the median # of shoots (e.g. 3)

```{r}
# ha_sub <-
#   ha %>%
#   filter(habitat %in% c("CF", "1-ha"))

# ha_sub <-
#   ha %>%
#   filter(habitat == "CF")

# ha_sub <-
#   ha %>%
#   filter(plot == 5750)

# ha_sub <-
#   ha %>%
#   filter(shts == median(shts, na.rm = TRUE))

ha_sub <- ha
```

```{r}
ha_sub %>% 
  group_by(year, plot) %>% 
  summarize(n_distinct(row), n_distinct(column))
```
There's something funky going on in 2009 with row and column positions. I opened an issue and this will get fixed eventually.

# General model structure

For each vital rate I'll include the number of shoots and habitat as fixed effects and plant ID and year as random effects. For the mixed effects models I'll use density at just two rings (0--5m and 5--10m) as fixed effects. There are probably too few plots (4 1-ha and 6CF) to use plot as a random effect, but I don't know how to code it as a fixed effect right now.

```
vital_rate ~ log(shts) + habitat + shts_0_2.5 + shts_2.5_5 + (1|year) + (1|ha_id_number) + (1|habitat:plot)
```

```{r}
ha_sub %>% 
  group_by(habitat) %>% 
  summarize(length(unique(plot)))
```

# Growth

For this I'm going to use shoot number. Very closely related to height, but better behaved distribution and not sensitive to plants being knocked over.

## Distribution

Number of shoots is discrete, but not *really* count data.  I'll try a poisson distribution and a lognormal distribution.

```{r}
mpois <-
  glmer(
    shts_next ~
      log_shts + 
      habitat +
      shts_0_2.5 + shts_2.5_5 +
      (1|ha_id_number) +
      (1|plot) +
      (1|year_post),
    family = poisson(link = "log"),
    data = ha_sub
  )

check_overdispersion(mpois) #actually underdispersed

mnorm <-
  glmer(
    shts_next ~ 
      log_shts +
      habitat +
      shts_0_2.5 + shts_2.5_5 +
      (1|ha_id_number) +
      (1|plot) +
      (1|year_post),
    family = gaussian(link = "log"),
    data = ha_sub
  )
```


```{r}
AICtab(mpois, mnorm)
compare_performance(mpois, mnorm, rank = TRUE)
```

Lognormal distribution fits best according to AIC, although poisson has lower RMSE.  I guess despite being discrete, this isn't really "count" data *per se*.  The lognormal model doesn't have problems with singularity that the poisson model has.  Both have problems with heteroscedasticity. A log-transformation of the response doesn't fix the heteroscedatsticyt either. I'll go with log-normal.

```{r}
m_growth <- mnorm
```

```{r}
x <- check_heteroscedasticity(m_growth)
plot(x)
```


## Random effects

Plot:

```{r}
m_growth2 <- update(m_growth, .~. - (1|plot))
AICtab(m_growth, m_growth2)
```

Plant ID:

```{r}
m_growth3 <- update(m_growth2, .~. - (1|ha_id_number))
AICtab(m_growth2, m_growth3)
```

Can't remove plant ID

Year:

```{r}
m_growth4 <- update(m_growth2, .~. - (1|year_post))
AICtab(m_growth, m_growth2, m_growth3, m_growth4)
```
Can remove year

## Does density matter beyond immediate surroundings?

```{r}
Anova(m_growth4)
fixef(m_growth4)
```

- Just 5750: marginaly significant negative density dependence at 2.5--5m
- Only CF: no significant effect of density dependence
- Only 3-shoot plants: no significant effect of density dependence
- Full dataset: No density dependence

# Survival

Pre-reproductive census, so plants live/die in same year as `shts` and `ht`

```{r}
m_surv <-
  glmer(
    surv ~
      log_shts +
      habitat +
      shts_0_2.5 + shts_2.5_5 +
      (1|ha_id_number) +
      (1|plot) +
      (1|year_post), 
    family = binomial, data = ha_sub
  )
```

## Random effects

Plot:

```{r}
m_surv2 <- update(m_surv, .~. - (1|plot))
AICtab(m_surv, m_surv2)
```

Plant ID:

```{r}
m_surv3 <- update(m_surv2, .~. - (1|ha_id_number))
AICtab(m_surv2, m_surv3)
```

Close to equivalent, so remove plant ID.  This makes sense, as plants only die once!

Year: 

```{r}
m_surv4 <- glm(surv ~ 
                 log_shts +
                 habitat +
                 shts_0_2.5 + shts_2.5_5, 
                family = binomial, data = ha_sub)
AICtab(m_surv4, m_surv3)
```
glm is best

## Density dependence?

```{r}
Anova(m_surv4)
coef(m_surv4)
```

- Just 5750: no density dependence
- Only CF: no density dependence
- Only 3-shoot plants: Marginally significant density dependence.  Negative at 0--2.5m, positive at 2.5--5m
- Full dataset: no density dependence


# Flowering probability

Make a binary column

```{r}
ha_sub <- 
  ha_sub %>% 
  mutate(flwr = as.integer(infl > 0), .before = infl)

unique(ha_sub$flwr)
```

Can't do this model because no variation in flowering.

```{r eval=FALSE}
m_flwr <-
  glmer(
    flwr ~ log_shts + habitat + shts_0_2.5 + shts_2.5_5 +
      (1|ha_id_number) + (1|year_post) + (1|habitat:plot),
    family = binomial, data = ha_sub
  )
```

# Kernel approach

I'd like to take the approach in Teller et al. 2016, but the code is so convoluted that it is not adaptable. Instead, I'll start by trying to adapt the `dlnm` approach.

## Set up the crossbasis

```{r}
Q <-
  ha_sub %>%
  select(shts_0_0.5:shts_4.5_5) %>%
  as.matrix()

L <-
  matrix(seq(0.25, 4.75, by = 0.5), #use midpoint of r1 and r2
         nrow = nrow(Q),
         ncol = ncol(Q),
         byrow = TRUE)
```


```{r}
library(dlnm)
library(mgcv)
library(visibly) # better diagnostic visulazations.  one of several packages for this.
source(here("R", "utils.R"))
```

## Growth

```{r}
g_growth <-
  gam(shts_next ~ 
        # s(ha_id_number, bs = "re") + #this takes waaay too long to converge
        s(plot, bs = "re") +
        log_shts + #when modeled as a spline, edf is essentially a line
        habitat +
        s(Q, L,
          bs = "cb",
          k = c(2,2),
          xt = list(bs = "cr")),
      family = gaussian(link = "log"),
      data = ha_sub,
      method = "REML")
```


```{r}
plot_gam_check(g_growth)
```


```{r}
anova(g_growth)
```

Effect of size on size(t+1):

```{r}
plot(g_growth, pages = 1)
```

Effects of density:


```{r}
pred_growth <- pred_cb(Q, L, g_growth)
```

Which predicted values are too far from data to sensibly plot?  (this is modeled after `mgcv::exclude.too.far`, which does not work for these models)

```{r}
dat <-
  ha_sub %>%
  select(shts_0.5_1:shts_4.5_5) %>% 
  pivot_longer(everything(),
               names_prefix = "shts_",
               names_sep = "_",
               names_to = c("inner", "outer"),
               names_transform = list(inner = as.numeric, outer = as.numeric),
               values_to = "x") %>% 
  mutate(lag = (inner + outer) / 2)


which.too.far <- function(grid, data, x, y, dist = 0.1) { 
  x <- enquo(x)
  y <- enquo(y)
  # x <- quo(x)
  # y <- quo(lag)
  
  grid1 <-
    grid %>% 
    mutate(min_g_x = min(!!x, na.rm = TRUE),
           min_g_y = min(!!y, na.rm = TRUE),
           g_x = !!x - min_g_x,
           g_y = !!y - min_g_y) %>% 
    mutate(max_g_x = max(g_x, na.rm = TRUE),
           max_g_y = max(g_y, na.rm = TRUE),
           g_x = g_x / max_g_x,
           g_y = g_y / max_g_y)
  
  data1 <-
    data %>% 
    mutate(d_x = (!!x - first(grid1$min_g_x)) / first(grid1$max_g_x),
           d_y = (!!y - first(grid1$min_g_y)) / first(grid1$max_g_y))
  
 
  if (dist < 0)
    stop("supplied dist negative")
  
  #where dat is a 2-column matrix of x and y coords of the true data used to build the model
  min_dist <- function(g_x, g_y, dat) {
    dat[,1] <- dat[,1] - g_x
    dat[,2] <- dat[,2] - g_y
    min(
      sqrt(
        (dat[,1]^2 + dat[,2]^2)
      ), na.rm = TRUE
    )
  }
  o <- 
    grid1 %>%
    rowwise() %>%
    mutate(min_dist = min_dist(g_x, g_y, cbind(data1$d_x, data1$d_y)),
           too.far = min_dist > dist) %>% 
    select(-g_x, -g_y, -max_g_x, -max_g_y, -min_g_x, -min_g_y)
  return(o)
}

pred_growth <- which.too.far(pred_growth, dat, x = x, y = lag)
```


```{r}
pred_growth %>%
  filter(min_dist < 0.1) %>%
  ggplot(aes(x = x, y = lag, z = exp(fitted), fill = exp(fitted))) +
  geom_raster(interpolate = TRUE) +
  geom_contour(color = "grey50", size = 0.4) + 
  scale_y_continuous("distance (m)", expand = c(0,0)) +
  scale_x_continuous("conspecific density (shoots/m^2)", expand = c(0,0)) +
  scale_fill_viridis_c("#shoots (t+1)", option = "A")
```





Plot a "slice" through 5m

```{r}
pred_growth %>%
  filter(min_dist < 0.1) %>% 
  filter(lag == 0.75) %>% 
  ggplot(aes(x = x, y = exp(fitted), ymin = exp(fitted - 1.96*se.fit), ymax = exp(fitted + 1.96*se.fit))) +
  geom_line() + 
  geom_ribbon(alpha = 0.3) +
  geom_point(data = ha_sub, aes(x = shts_0_0.5, y = shts_next), inherit.aes = FALSE) +
  coord_cartesian(ylim = c(0,20))
```


- 5750 only: essentially flat surface, except for positive density dependence at 5m.  Seems spurious, would want to see CI.
- CF only: similar.  Essentially flat except for impossibly large positive density dependence at 5 m (expected value of 200+ shoots at highest conspecific density)
- 3-shoot plants only: No significant effect of density.
- Full dataset: Significant, but same pattern.  Large effects only at 5m.  Probably driven by a few extreme values of high-density plots.


## Survival

```{r}
g_surv <-
  gam(surv ~
        s(plot, bs = "re") +
        s(log_shts) +
        habitat +
        s(Q, L,
          bs = "cb",
          xt = list(bs = "cr")),
      family = binomial,
      data = ha_sub,
      method = "REML")
```

```{r}
# plot_gam_check(g_surv)
anova(g_surv)
```

Effect of size on survival:

```{r}
plot(g_surv, pages = 1)
```


```{r}
pred_surv <- pred_cb(Q, L, g_surv)
ggplot(pred_surv, aes(x = x, y = lag, z = plogis(fitted), fill = plogis(fitted))) +
  geom_raster(interpolate = TRUE) +
  geom_contour(color = "grey50", size = 0.4) + 
  scale_y_continuous("distance (m)", expand = c(0,0)) +
  scale_x_continuous("conspecific density (shoots/m^2)", expand = c(0,0)) +
  scale_fill_viridis_c("P(survival)", option = "A")
```

- 5750 only: No significant density dependence
- CF only: Also not significant.
- 3-shoot plants only: no significant density dependence
- Full dataset: no significant effect of density dependence.
