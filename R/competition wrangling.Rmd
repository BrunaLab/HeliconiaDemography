---
title: "Competition"
author: "Eric R. Scott"
date: "2020-09-09"
output: 
  html_notebook: 
    highlight: kate
    theme: yeti
    toc: yes
    toc_float: yes
    number_sections: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(here)
library(conflicted)
library(glue)
library(car)
library(skimr)

source(here("R", "utils.R"))

conflict_prefer("lag", "dplyr")
conflict_prefer("filter", "dplyr")
conflict_prefer("select", "dplyr")
```

*Last compiled: `r Sys.Date()`*

# Purpose

Competition kernel. Teller et al.

I want to use the `row` and `colunn` to figure out how many neighbors each plant has. I should exclude plants on edges, because I don't know about their neighbors outside of the plot.

# Load Data

```{r data, echo=TRUE}
ha <- read_rds(here("analysis", "data", "derived_data", "ha_survey.rds"))
```

Make numeric row and column numbers for easier data handling later.

```{r}
# as.factor(ha$row) #levels are alphabetical order by default, which is perfect.  Except for row "L", not sure what that's about.
ha <- 
  ha %>% 
  mutate(row_number = as.integer(as.factor(row)), .after = row,
         column = as.integer(column)) %>% 
  filter(row != "L") # just get rid of the few plants in a row "L".--only affects one plot
```

```{r}
skim(ha)
```

# Calculating density at different distances
First, a small example as proof of concept:

```{r}
ha_test <-
  ha %>%
  filter(plot == first(plot)) %>%
  filter(year == first(year)) %>%
  filter(row_number <=3, column <=3) %>% 
  add_column(plant = 1) #just a dummy indicator column for use later
ha_test
```

I'll make use of `expand_grid()` to create every combination of row and column (cell), and `dist()` to calculate the distance between every cell and every other cell.

```{r}
#all possible combination of row and column ID
grid_coords <- expand_grid(row = 1:3, col = 1:3) %>% as.matrix() 

#calculate distrance from every coord to every other coord
d <- dist(grid_coords*10, #because each grid cell is 10m x 10m
          diag = FALSE,
          upper = TRUE) %>% 
  as.matrix()

rownames(d) <- colnames(d) <- paste(grid_coords[ , 1], grid_coords[ , 2], sep = ",")
d
```

Now I can turn this into a tidy/long format. This shows the distance from (`row_from`, `column_from`) to (`row_to`, `column_to`).

```{r}
dist_df <-
  as.data.frame(d) %>% 
  rownames_to_column(var = "from") %>% 
  pivot_longer(-from, names_to = "to", values_to = "dist") %>% 
  separate(from, into = c("row_from", "column_from")) %>% 
  separate(to, into = c("row_to", "column_to")) %>% 
  mutate(across(where(is.character), as.integer))
head(dist_df)
```

Then we can summarize the real data to figure out how many plants are in each grid cell.  Here, I'm just using a small subset that corresponds to a single 3x3 plot

```{r}
plant_summary <-
  ha_test %>% 
  group_by(row_number, column) %>% 
  summarize(n_plants = n(),
            n_shts = sum(shts)) %>% 
  rename(row = row_number)
plant_summary
```
Now I can join these two data frames.

```{r}
dist_full <- full_join(dist_df, plant_summary, by = c("row_to" = "row", "column_to" = "column"))
head(dist_full)
```
The way to read this is for a plant in [1,1] the cell [1,1] is 0m away and has 3 plants in it.  For a plant in [1,1], cell [1,2] is 10m away and there is 1 plant in it.  For a plant in [1,1], cell [2,3] is 22.36m away and there are 9 plants in it, etc.

Here's another way to visualize this using `xtabs()`:

```{r}
xtabs(plant ~ row_number + column, ha_test)
```

So now I can filter this and summarize to calculate neighbor density at arbitrary distances for every grid cell.

```{r}
#density between 5m and 15m away
dist_5_15 <-
  dist_full %>% 
  filter(dist >=5, dist <15) %>% 
  group_by(row_from, column_from) %>% 
  summarize(n_neighbors_5_15 = sum(n_plants, na.rm = TRUE),
            n_cells = n(),
            density_5_15 = n_neighbors_5_15/n_cells,
            shtsper_5_15 = sum(n_shts, na.rm = TRUE)/n())
```
So at [1,1] there are only 3 cells between 5 and 15m away, there are a total of 6 plants in those cells, so the conspecific density at that distance is 2.0 plants / 100m^2 or 3.66 shoots / 100m^2

Then I can join that back to the original data set

```{r}
full_test <- full_join(ha_test, dist_5_15, by = c("row_number" = "row_from", "column" = "column_from"))
head(full_test)
```

## Scaling up

I'm going to scale up using a nested dataframe and the magic of list-columns!  The advantage of this over splitting the one dataframe into a dataframe for every plot:year combo and using a for-loop or `map()` is that it keeps the plot and year structure intact and I don't have to figure out how to re-join the data at the end.

First, nest the dataframe by plot and year.

```{r}
ha_nest <-
  ha %>% 
  group_by(plot, year) %>% 
  group_nest()
```

Then, do the setup by calculating the `grid_coords` and `d` for every plot:year combo.

```{r}
ha_nest_dist <- 
  ha_nest %>% 
  #every combination of row and column:
  mutate(grid_coords = map(
    data, 
    ~expand_grid(row = min(.x$row_number):max(.x$row_number),
                 col = min(.x$column):max(.x$column)) %>% as.matrix()
    )) %>% 
  #matrix describing euclidean distance from every point to every other point:
  mutate(d = map(
    grid_coords,
    ~{
      d <- dist(.x * 10, #because each grid cell is 10m x 10m
                diag = FALSE,
                upper = TRUE) %>% 
        as.matrix()
       colnames(d) <- rownames(d) <- paste(.x[,1], .x[,2], sep = ",")
      d
    }
    )) %>% 
  #tidy data frame version of d
  mutate(dist_df = map(d, ~{
    as.data.frame(.x) %>% 
      rownames_to_column(var = "from") %>% 
      pivot_longer(-from, names_to = "to", values_to = "dist") %>% 
      separate(from, into = c("row_from", "column_from")) %>% 
      separate(to, into = c("row_to", "column_to")) %>% 
      mutate(across(where(is.character), as.integer))
  }
  ))
```

Now, create that summary tibble counting the number of shoots in each grid cell for every plot:year combo, join, and unnest.

```{r}
ha_dist <-
  ha_nest_dist %>% 
  #summarize each year:plot to count number of plants in each grid cell
  mutate(n_shts_sum = map(data, ~{
    .x %>% 
      # add_column(plant = 1) %>% 
      group_by(row_number, column) %>% 
      summarize(n_shts = sum(shts)) %>% 
      rename(row = row_number)
  }
  )) %>% 
  #join with tidied distance matrix to get dataframe for distance from every row
  #and column to every other row and column
  mutate(dist_full = map2(dist_df, n_shts_sum, ~{
    full_join(.x, .y, by = c("row_to" = "row", "column_to" = "column"))
  } 
  )) %>% 
  select(plot, year, dist_full) %>% 
  unnest(dist_full)

ha_dist
```

Now, with `ha_dist`, I can filter by distance, calculate a density, and the join to the original data.

```{r}
dens_0_10 <-
  ha_dist %>% 
  filter(dist>0 & dist <=10) %>% 
  group_by(plot, year, row_from, column_from) %>% 
  summarize(density_0_10 = sum(n_shts, na.rm = TRUE)/n())
left_join(ha, dens_0_10, by = c("plot", "year", "row_number" = "row_from", "column" = "column_from")) %>% 
  arrange(plot, year, row_number, column)
```

I'll do this for different distances programmatically.

```{r}
width <- 10 #meters
max <- 100 #meters
L <- seq(0, max-width, by = width)
U <- seq(0 + width, max, by = width)

out <- 
  map2(L, U, ~{
  ha_dist %>%
    filter(dist >= .x & dist < .y) %>% 
    group_by(plot, year, row_from, column_from) %>%
    summarize(!!glue::glue("density_{.x}_{.y}") := sum(n_shts, na.rm = TRUE)/n())
})

x <- out[[1]]
for (i in 2:length(out)) {
  x <- full_join(x, out[[i]], by = c("plot", "year",  "row_from", "column_from"))
}  
x
```

Join to original data

```{r}
ha_new <- 
  left_join(ha, x,
          by = c("plot", "year", "row_number" = "row_from", "column" = "column_from")) %>% 
  arrange(plot, year, row_number, column)
ha_new
```

```{r}
library(naniar)
vis_miss(ha_new %>% select(starts_with("density")))
```
The furthest distance I can estimate density for all plants is 60m.  Past that, in order to estimate effects of density, I would have to drop plants.  Even for closer plants though, the estimates may be biased because they do not include plants outside of the plot. That is, neighbor density for plants near the edges is based on a smaller sample than for plants near the center.


# Write to cleaned data

```{r}
write_rds(ha_new, here("analysis", "data", "derived_data", "ha_density.rds"))
```

