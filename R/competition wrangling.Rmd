---
title: "Competition"
author: "Eric R. Scott"
date: "2020-09-09"
output: 
  html_notebook: 
    highlight: kate
    theme: yeti
    toc: yes
    toc_float: yes
    number_sections: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(here)
library(conflicted)
library(glue)
library(car)
library(skimr)

source(here("R", "utils.R"))

conflict_prefer("lag", "dplyr")
conflict_prefer("filter", "dplyr")
conflict_prefer("select", "dplyr")
```

*Last compiled: `r Sys.Date()`*

# Purpose

Competition kernel. Teller et al.

I want to use the `row` and `colunn` to figure out how many neighbors each plant has. I should exclude plants on edges, because I don't know about their neighbors outside of the plot.

# Load Data

```{r data, echo=TRUE}
ha <- read_rds(here("analysis", "data", "derived_data", "ha_survey.rds"))
```

Make numeric row and column numbers for easier data handling later.

```{r}
# as.factor(ha$row) #levels are alphabetical order by default, which is perfect.  Except for row "L", not sure what that's about.
ha <- 
  ha %>% 
  mutate(row_number = as.integer(as.factor(row)), .after = row,
         column = as.integer(column)) %>% 
  filter(row != "L") # just get rid of the few plants in a row "L".--only affects one plot
```

```{r}
skim(ha)
```

# Calculating density at different distances

## Start with one plot

```{r}
ha_test <- ha %>% filter(plot == first(plot))
```

To calculate neighbors at a certain distance I first calculate the number of plants in each grid cell, as a matrix using the `xtabs()` function.  I do this for each year separately, and eventually will apply this to every year x plot combination.

```{r}
ha_g <- 
  ha_test %>% 
  add_column(plant = 1) %>% 
  group_by(year)

neighbors <-
  ha_g %>% 
  group_split() %>% 
  map(~xtabs(plant ~ row + column, .x)) %>% 
  set_names(group_keys(ha_g)$year)
head(neighbors, 3)
```

Then, for every grid cell, I create a masking matrix using a custom function, `mat_rect()`, in utils.R.

```{r}
I1 <- mat_rect(D = 0, nrow = 5, ncol = 10)
```

Then for each year in `neighbors`, I multiply the xtabs matrix by the masking matrix and take the sum to get the number of plants in that distance around each focal plant.

```{r}
n_plants_1 <-
  map_df(neighbors,
  function(x) map_dbl(I1, ~ sum(x * .x)) %>% 
    enframe(value = "n_plants_1") %>% 
    separate(name, into = c("row", "column"), sep = ",", convert = TRUE),
  .id = "year"
) %>% 
  mutate(year = as.integer(year)) #for joining later
n_plants_1
```
Then, I can join this with the original data frame

```{r}
ha_test <- left_join(ha_test, n_plants_1, by = c("row_number" = "row", "column", "year"))
```

## Scaling up

One difficulty is that the size of plots varies:

```{r}
ha %>% 
  group_by(plot) %>% 
  summarize(nrows = max(row_number), ncols = max(column))
```
This means there has to be a different list of masking matrices for each plot, in addition to a different density matrix for each plot:year. 

Also, occasionally the density matrix `neighbors` isn't consistent from year to year.  E.g. a column has no plants in it in one year and has a plant in it the next year.

So, It might be easiest to split by plot, do this stuff on each plot, then re-join?

```{r}
ha_plots <- ha %>% group_by(plot) %>% group_split()
```

```{r}
#function to calculate neighbor density for a single plot (every year).
df_plot <- ha_plots[[4]]
calc_dens_neighbor <-
  function(df_plot, D) {
  ha_g <- 
    df_plot %>% 
    add_column(plant = 1) %>% 
    group_by(year)
  
  neighbors <-
    ha_g %>% 
    group_split() %>% 
    map(~xtabs(plant ~ row + column, .x)) %>% 
    set_names(group_keys(ha_g)$year)
  
  I <- mat_rect(
    D = D,
    nrow = max(df_plot$row_number),
    ncol = max(df_plot$column)
  )
  
  n_plants <-
    map_df(neighbors,
           function(x) map_dbl(I, ~ sum(x * .x)) %>%
             enframe(value = glue::glue("n_plants_{D}")) %>%
             separate(name, into = c("row", "column"), sep = ",", convert = TRUE),
           .id = "year"
    ) %>%
    mutate(year = as.integer(year))
    
  out <- left_join(df_plot, n_plants, by = c("row_number" = "row", "column", "year"))
  return(out)
}
```

For one plot:

```{r}
calc_dens_neighbor(ha_plots[[1]], D = 3)
```

But, doesn't work when a plot has empty rows or columns in some years but not others.

```{r}
calc_dens_neighbor(ha_plots[[4]], D = 3)
```

Alternative with list columns


```{r}
calc_dens_neighbor <-
  function(df_plot, D) {
    
    calc_dens <- function(neighbors, I, D) {
      out <- map_dbl(I, ~ sum(neighbors * .x)) %>%
        enframe(value = glue::glue("n_plants_{D}")) %>%
        separate(name, into = c("row_number", "column"), sep = ",", convert = TRUE)
      return(out)
    }
    
    df_nested <-
      df_plot %>% 
      add_column(plant = 1) %>% 
      group_nest(year) %>% 
      mutate(neighbors = map(data, ~xtabs(plant ~ row + column, .x))) %>% 
      mutate(I = map(neighbors, ~{
        mat_rect(
          D = D,
          nrow = nrow(.x),
          ncol = ncol(.x)
        )
      }))
    
    out_nested <- 
      df_nested %>% 
      mutate(n_plants = map2(neighbors, I, ~calc_dens(.x, .y, D)))
    
    out_joined <- out_nested %>%
      mutate(d = map2(data, n_plants,
                      ~left_join(.x, .y, by = c("row_number", "column"))))

    out <- out_joined$d %>% bind_rows()
    return(out)
  }
```



```{r}
ha_plots %>% map_df(~calc_dens_neighbor(.x, 2))
```

