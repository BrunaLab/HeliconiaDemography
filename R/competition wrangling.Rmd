---
title: "Competition"
author: "Eric R. Scott"
date: "2020-09-09"
output: 
  html_notebook: 
    highlight: kate
    theme: yeti
    toc: yes
    toc_float: yes
    number_sections: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(here)
library(conflicted)
library(glue)
library(car)
library(skimr)
library(furrr)
library(janitor)

source(here("R", "utils.R"))

conflict_prefer("lag", "dplyr")
conflict_prefer("filter", "dplyr")
conflict_prefer("select", "dplyr")
```

*Last compiled: `r Sys.Date()`*

# Purpose


# TODO:

- filter out focal plants where donut goes out of plot. (filter(distance_to_edge > outer_circle_radius))
- Using all years is not estimating density accurately. Focal plants are not moving, but in other years there are neighbors without known coordinates. Solution: only use the three transitions where we know the coords of every plant?  Or assume births and deaths don't change density significantly?

# Load Data

```{r data, echo=TRUE}
# demographic data
ha <- read_rds(here("analysis", "data", "derived_data", "ha_survey.rds"))
# data from previous study: Uriarte M, Bruna EM, Rubim P, et al (2010) Effects
# of forest fragmentation on the seedling recruitment of a tropical herb:
# assessing seed vs. safe-site limitation. Ecology 91:1317â€“1328.
# https://doi.org/10.1890/09-0785.1

coords <-
  read.table(here("analysis", "data", "raw_data", "adults0607_light.txt")) %>%
  as_tibble() %>%
  clean_names()
```

`ha` contains x and y coords for each plant from 2009 *within each grid cell*.  `coords` contains x and y coordinates for each plant in 2006 and 2007 relative to the entire plot.  I need to join these data sources and offset the coordinates in the `ha` dataset correctly.  I'm going to remove `year` from the `coords` dataset and assume that plants aren't moving.

# Join data

Getting things to match up:

```{r}
coords2 <- 
  coords %>% 
  select(plot = site, tag_number, row, column, plot_x, plot_y, x, y) %>% 
  mutate(plot = case_when(
    plot == "Cabo Frio" ~ "CaboFrio-CF",
    plot == "Dimona CF" ~ "Dimona-CF",
    plot == "Florestal" ~ "Florestal-CF",
    plot == "PA-CF" ~ "PortoAlegre-CF",
    TRUE ~ plot
  )) 
```

Summarize so there is only one set of coordinates per plant. Averaging as I'm assuming any difference in coordinates between '06 and '07 is not because the plant moved.

```{r}
coords3 <-
  coords2 %>%
  group_by(plot, tag_number) %>% 
  # rowwise() %>% 
  summarize(across(where(is.character), first),
            across(where(is.numeric), mean)) %>% 
  rename(x_07 = x,
         y_07 = y)
```

```{r}
ha_coords <- left_join(ha, coords3, by = c("plot", "row", "column", "tag_number"))
```
# Tidy

Now, use the plot_x and plot_y variables to correctly offset the x and y coords from 2009.

```{r}
ha_coords2 <- 
  ha_coords %>% 
  mutate(x_adj = x_09 + ((plot_x - 1) * 10),
         y_adj = y_09 + ((plot_y - 1) * 10),
         .after = y_09)
```

Now, I'll just average across the three years and assume that any differences are measurement error and not because plants moved.

```{r}
ha_coords3 <-
  ha_coords2 %>% 
  rowwise() %>% 
  mutate(x = mean(c(x_adj, x_07), na.rm = TRUE),
         y = mean(c(y_adj, y_07), na.rm = TRUE)) %>% 
  #replace NaN's generated when mean of only NAs is taken
  mutate(across(c(x, y), ~ifelse(is.nan(.), NA, .))) %>% 
  #remove intermediate coordinates
  select(ranch, bdffp_reserve_no, plot, habitat,
         ha_id_number, tag_number, row, column,
         x, y, year, ht, ht_next, shts, shts_next,
         infl, surv, code_notes, code2)
```

# Filter

To model the effect of density, I'm only going to use the subset of plants that I have coordinates for.

**NOTE:** There is a **problem** with this.  By using all the years and filtering the data to just include plants with coordinates from 2006, 2007, and 2009, I am not estimating density accurately.
```{r}
ha_xy <-
  ha_coords3 %>% 
  filter(!is.na(x), !is.na(y)) %>% 
  ungroup()
```

# Calculate density

Now the challenge is to calculate the density of surrounding shoots for every focal plant at different distances.

```{r}
# function to calculate euclidean distance between two points
eu_dist <- function(p1, p2) {
  sqrt(sum((p1 - p2)^2))
}
# x = c(0,0)
# y = c(3,3)
# eu_dist(x, y)
```

## Proof of concept

Start with single plot

```{r}
y1p1 <- ha_xy %>% 
  filter(year == first(year),
         plot == first(plot))
y1p1
```

```{r}
add_density_cols <- function(df, L, U, by, verbose = FALSE) {
  
  eu_dist <- function(p1, p2) {
    sqrt(sum((p1 - p2)^2))
  }
    
  d <- seq(L, U, by = by)

  df_out <- 
    future_map_dfr(1:nrow(df), function(r) { #loop through rows/plants
      #get coordinates for that plant
      focal_plant <- t(df[r, c("x", "y")])
      
      #calculate distance to every other plant
      focal_df <-
        df %>%
        rowwise() %>%
        mutate(dist = eu_dist(focal_plant, c(x, y)))
      
      #get total number of shoots at every ring
      future_map2_dfc(lag(d)[-1], d[-1],
               ~ transmute(focal_df,
                           !!glue("shts_{.x}_{.y}") := shts * (dist > .x & dist <= .y))) %>% 
        #excludes focal plant with dist == 0
        ungroup() %>% 
        summarize(across(everything(), ~sum(., na.rm = TRUE)))
    })
  
  df_out <- bind_cols(df, df_out) #join to original data
  return(df_out)
}

add_density_cols(y1p1, L = 0, U = 10, by = 5)

```

If I want this to be in units of shoots/m^2, then I need to calculate the area of the donut:

$$
A = \pi(U^2 - L^2)
$$
But also, like, truncate that donut if it passes outside of the plot.  I don't know how to do that.

```{r}
plan(multiprocess)
```

## Apply to entire dataset

```{r}
ha_xy2 <-
  ha_xy %>% 
  group_by(plot, year) %>% 
  group_split() %>% 
  # head() %>% #test with 6 df to see how long it will take.
  future_map(~{
      add_density_cols(.x, L = 0, U = 10, by = 5) 
    }) %>% 
  bind_rows()
beepr::beep(4)
ha_xy2
```

Yay! It worked! And it didn't even run that long!

## Remove plants on edge

I should remove plants on the edge because the entire "donut" isn't included for them.  I can do this by finding the distance to the nearest edge, then checking if that distance is greater than the outer radius for the donuts, and if so, setting that density value to `NA`.

Plots are 10 columns by 5 rows so the x should range from 0--100 and the y should range from 0--50.

```{r}
# example plant at 94, 45
# min(c(94, 100 - 94, 45, 50 - 45))

ha_density <-
  ha_xy2 %>% 
  rowwise() %>% 
  mutate(
    dist_to_edge = min(x, 100 - x, y, 50 - y),
    shts_0_5 = ifelse(
      dist_to_edge < 5,
      NA,
      shts_0_5
    ),
    shts_5_10 = ifelse(
      dist_to_edge < 10,
      NA,
      shts_5_10
    ))

ha_density
```
# Write to file

```{r}
write_rds(ha_density, here("analysis", "data", "derived_data", "ha_density.rds"))
```

