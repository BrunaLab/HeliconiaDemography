---
title: "Heliconia IPM Practice"
author: "Eric R. Scott"
date: "2020-08-20"
output: 
  html_notebook: 
    highlight: kate
    theme: yeti
    toc: yes
    toc_float: yes
    number_sections: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(here)
library(conflicted)
library(skimr)
library(performance)
library(lme4)
library(bbmle)
library(broom)
library(broom.mixed)
library(popbio)

conflict_prefer("lag", "dplyr")
conflict_prefer("filter", "dplyr")
conflict_prefer("slice", "dplyr")
```

*Last compiled: `r Sys.Date()`*

# TODO:

- I feel like there is maybe a more sophisticated method of dealing with "zombie" plants.  Take another look at Elizabeth's lectures or whats-her-name's paper on terrestrial orchids.
- Not sure how to incorporate overdispersion (significant random effect of `tag_number`)

# Purpose

Practice constructing an IPM using (a subset of) the [Heliconia demographic data](https://github.com/embruna/HeliconiaDataPaper/tree/master/data_clean).

# Load Data

```{r data, echo=TRUE}
demog <- read_csv(here("analysis", "data", "raw_data", "Ha_survey_with_Zombies.csv"), col_names = TRUE,
               cols(plot = col_character(),
                    bdffp_reserve_no = col_character(),
                    shts = col_integer(),
                    year = col_integer(),
                    infl = col_integer(),
                    tag_number = col_character()))

unique(demog$ranch)
unique(demog$code.notes)
unique(demog$code2)
unique(demog$size)

skim(demog)
```

## Data Dictionary

`demog`: Demography data for *Heliconia acuminatata* experiment at BDFFP

- `plot` (character):
- `size` (character): fragment size
- `ranch` (character): "Dimona", "Esteio-Colosso", or "PortoAlegre".  The three ranches that make up BDFFP.
- `bdffp_reserve_no` (character): Official BDFFP reserve designation
- `tag_number` (numeric): plant tag# within plot (not unique)
- `row` (character): spatial location in plot
- `column` (numeric): spatial location in plot
- `year` (numeric): year of survey
- `ht` (numeric): plant height.  Plants not straightened before measurement.
- `shts` (numeric): number of shoots
- `infl` (numeric): number of inflorescences
- `code.notes` (character): 
    - "plant missing" = plant was not found in that survey.  May not be dead, may be found in subsequent surveys.
    - "dead" = plant lost all above-ground tissue.  May resprout in a subsequent year.
    - "ULY" = 
    - "sdlg" = seedling, defined as a year 1 plant.
    - "tag missing" = ID tag labeling the plant was missing.  Plants were given new tags and researchers did their best to match up new tag and old tag. **(that column isn't in this version though)**
- `code2` (character): "initial.tag.yr" = marks the first year plant appeared in a survey.  Not necessarily a seedling.


# Data Wrangling

Take subset for messing around

```{r}
km41 <- demog %>% filter(bdffp_reserve_no == "1501") %>% select(-bdffp_reserve_no)
km41 %>% count(plot)
```

Narrow down to just one plot for now

```{r}
km41 <- km41 %>% filter(plot == "5750")
km41 %>% count(tag_number) %>% count(n)

km41 %>% count(tag_number) %>% ggplot() + geom_histogram(aes(n))
```
Plants have up to 12 years of data

## Survival and reproduction

I need to have a column for fate.  Made difficult by "zombie" plants.

```{r}
km41
```
When is a plant really dead?  When it's the last non-`NA` value for that particular tag number before the max date.

```{r}
km41 %>% group_by(tag_number) %>% summarize(max(year))
max(km41$year)
```


```{r}
km41_2 <- 
  km41 %>%
  group_by(tag_number) %>% 
  # Routine for figuring out last year of data collected
  mutate(x = cumsum(ht > 0 & !is.na(ht))) %>%
  # mutate(x = cumsum(lag(ht) > 0 & !is.na(lag(ht)))) %>%
  mutate(n = 1:n()) %>% 
  mutate(fate = if_else(
    n == which.max(x==max(x)),
    "died",
    NA_character_
  )) %>% 
  # remove rows after plant is dead
  filter(row_number() <= which(fate == "died")[1]) %>% 
  # remove "died" if last year of data (2009)
  ungroup() %>% 
  mutate(fate = if_else(year == max(year), NA_character_, fate)) %>% 
  select(-n, -x)
# km41_2 %>% filter(fate == "died") %>% count(year)
```
```{r}
km41_2 %>% count(fate)
```
359 plants died

```{r}
km41_2 <- km41_2 %>% mutate(surv = ifelse(is.na(fate), 1, 0))
```

```{r}
km41_2 <- km41_2 %>% mutate(flowered = infl > 0)
```

## Just flowering individuals

```{r}
km41_flowered <- km41 %>% filter(infl > 0)
```

## Lagged height for growth

```{r}
km41_2 <-
  km41_2 %>% 
  group_by(tag_number) %>% 
  mutate(ht_prev = lag(ht))
```

# IPM

Gotta look this up, but assuming that reproduction happens before survival

## Kernel

In words:

The number of individuals in a size class in year t+1 is a function of 

$$
K(z^\prime,z) = p_b(z)b(z)p_rc_0(z^\prime) + s(z)G(z, z^\prime)
$$
Reporduction:

- $p_b(z)$: probability of flowering as a function of size
- $b(z)$: number of inflorescences as a function of size. 
- $p_r$ mean # of seedlings produced per inflorescence.  This varies by year, not sure how to incorporate environmental stochasticity.
- $c_0(z^\prime)$ size distribution of new recruits

Growth & survival:

- $s(z)$ is survival probability as a function of size
- $G(z, z^\prime)$ is growth as a function of size.

## Reproduction

In this particular dataset the only information on reproduction is number of inflorescences per plant and total number of seedlings in a year.

### Probability of flowering

#### Model

Start with most complex: quadratic response, environmental stochasticity, and random variation among plants.

```{r}
meo_pflwr2 <- glmer(flowered ~ ht + I(ht^2) + (1|tag_number) + (1|year), family = binomial, data = km41_2)
```
Check random effects

```{r}
mo_pflwr2 <- glmer(flowered ~ ht + I(ht^2) + (1|tag_number), family = binomial, data = km41_2)
me_pflwr2 <- glmer(flowered ~ ht + I(ht^2) + (1|year), family = binomial, data = km41_2)
m_pflwr2  <-   glm(flowered ~ ht + I(ht^2), family = binomial, data = km41_2)
AICtab(meo_pflwr2, me_pflwr2, mo_pflwr2, m_pflwr2)
```
Keep both random effects.

Check quadratic

```{r}
meo_pflwr <- glmer(flowered ~ ht + (1|tag_number) + (1|year), family = binomial, data = km41_2)
AICtab(meo_pflwr, meo_pflwr2)
```

Keep quadratic

```{r}
augment(meo_pflwr2, type.predict = "response") %>% 
  # filter(tag_number %in% c(1, 101)) %>%
  ggplot(aes(x = ht, y = .fitted)) +
  geom_line(alpha = 0.2, aes(group = year)) +
  stat_summary_bin(geom = "point", fun = mean, aes(y = as.numeric(flowered)), bins = 80, alpha = 0.5)
```

Some years had super high survival, others very low.  Variation among plants.

#### Function

```{r}
fixef(meo_pflwr2)
```

$$
p(flower) = inv.logit(-7.423 + 0.181ht - 0.0008ht^2)
$$

Not sure how to incorporate random effects

```{r}
p_bz <- function(z) {
  coefs <- fixef(meo_pflwr2)
  linear.p <- coefs[1] + coefs[2]*z + coefs[3]*z^2
  p <- 1/(1+exp(-linear.p))
  return(as.numeric(p))
}
# predict(mm_pflwr2, newdata = data.frame(ht = 20, tag_number = "new"), allow.new.levels = TRUE) %>% plogis() ==
# p_bz(20)
```

### Number of infloresences

#### Model

```{r}
meo_flwrs2 <- glmer(infl ~ ht + I(ht^2) + (1|tag_number) + (1|year), family = poisson, data = km41_flowered)
```
```{r}
me_flwrs2 <- glmer(infl ~ ht + I(ht^2) + (1|year), family = poisson, data = km41_flowered)
mo_flwrs2 <- glmer(infl ~ ht + I(ht^2) + (1|tag_number), family = poisson, data = km41_flowered)
m_flwrs2 <- glm(infl ~ ht + I(ht^2), family = poisson, data = km41_flowered)
AICtab(meo_flwrs2, me_flwrs2, mo_flwrs2, m_flwrs2)
```

No random effects.

Check quadratic

```{r}
m_flwrs <- glm(infl ~ ht, family = poisson, data = km41_flowered)
AICtab(m_flwrs, m_flwrs2)
```

Go with simpler linear glm

```{r}
augment(m_flwrs, type.predict = "response") %>% 
  ggplot(aes(x = ht, y = .fitted)) +
  geom_line() +
  geom_jitter(aes(y = infl), alpha = 0.5, width = 0, height = 0.1)
```


#### Function

```{r}
b_z <- function(z) {
  coefs <- coef(m_flwrs)
  infl <- coefs[1] + coefs[2]*z
  return(as.numeric(infl))
}
```

### Probability of recruitment

#### Model

Estimated as number of recruits / number of inflorescences in year prev. year

```{r}
km41_rec_sum <- 
  km41 %>%
  group_by(year) %>% 
  summarize(recruits = sum(code.notes == "sdlg (1)", na.rm = TRUE),
            seeds_est = sum(lag(infl), na.rm = TRUE)) %>% 
  filter(year > 1998)
km41_rec_sum
```

```{r}
m <- glm(recruits ~ 1, offset = log(seeds_est), family = poisson, data = km41_rec_sum)
coef(m)
```

#### Function

```{r}
p_r <- as.numeric(exp(coef(m)))
p_r
```

So like 1.64 seedlings per inflorescence

### Size distribution of new recruits

#### Model

recruitment size

```{r}
km41_rec <- km41 %>% filter(code.notes == "sdlg (1)")
m_rec <- lm(ht ~ 1, data = km41_rec)
```

```{r}
coef(m_rec)
summary(m_rec)$sigma
```

#### Function

```{r}
c_0z1 <- function(z1) {
  mu <- coef(m_rec)[1]
  sig <- summary(m_rec)$sigma
  p.deRecr <- dnorm(z1, mean = mu, sd = sig)
  return(p.deRecr)
}
# c_0z1(20)
```

## Growth

### Model

Try modeling growth as height_t+1 ~ height_t.  Needs a random effect of tag_number, I think?
```{r}
meo_grow2 <- lmer(ht ~ ht_prev + I(ht_prev^2) + (1|tag_number) + (1|year), data = km41_2)
```
Test random effects

```{r}
me_grow2 <- lmer(ht ~ ht_prev + I(ht_prev^2) + (1|year), data = km41_2)
mo_grow2 <- lmer(ht ~ ht_prev + I(ht_prev^2) + (1|tag_number), data = km41_2)
m_grow2 <- lm(ht ~ ht_prev + I(ht_prev^2), data = km41_2)
AICtab(meo_grow2, me_grow2, mo_grow2, m_grow2)
```

Environmental stochastsicity, but not differences among plants

check quadratic

```{r}
me_grow <- lmer(ht ~ ht_prev + (1|year), data = km41_2)
AICtab(me_grow, me_grow2)
```

Quadratic is better.

```{r}
augment(me_grow2) %>% 
ggplot(aes(x = ht_prev, y = ht)) + 
  geom_point(alpha = 0.2) +
  geom_line(aes(y = .fitted, group = year), color = "blue", alpha = 0.2)
```
### Function

```{r}
fixef(me_grow2)
```

$$
ht_{t+1} = 2.143 + 1.056ht - 0.002ht^2
$$


```{r}
summary(me_grow2)$sigma
summary(me_grow2)$varcor
```

Not sure how to take random effect into account

```{r}
G_z1z <- function(z1, z) {
  coefs <- fixef(me_grow2)
  sig <- summary(me_grow2)$sigma #or shoudl this incorporate mixed effects somehow?

  mu <- coefs[1] + coefs[2]*z + coefs[3]*z^2
  p.den.grow <- dnorm(z1, mean = mu, sd = sig) #pdf of new size for current size
  return(p.den.grow)
}
```

## Survival

### Model
```{r}
meo_surv2 <- glmer(surv ~ ht + I(ht^2) + (1|tag_number) + (1|year), family = binomial, data = km41_2)
```
```{r}
me_surv2 <- glmer(surv ~ ht + I(ht^2) + (1|year), family = binomial, data = km41_2)
mo_surv2 <- glmer(surv ~ ht + I(ht^2) + (1|tag_number), family = binomial, data = km41_2)
m_surv2 <- glm(surv ~ ht + I(ht^2), family = binomial, data = km41_2)
AICtab(meo_surv2, me_surv2, mo_surv2, m_surv2)
```

Only environmental stochasticity.

Check quadratic

```{r}
me_surv <- glmer(surv ~ ht + (1|year), family = binomial, data = km41_2)

AICtab(me_surv, me_surv2)
```

Quadratic is better

```{r}
augment(me_surv2, type.predict = "response") %>% 
  ggplot(aes(x = ht, y = .fitted)) +
  geom_line(aes(group = year), color = "blue", alpha = 0.5) +
  stat_summary_bin(geom = "point", fun = mean, aes(y = surv), bins = 80, alpha = 0.5)
```

Survival is better in some years than others, especially for very small plants

### Function

```{r}
fixef(me_surv2)
```


$$
p(survive) = inv.logit(0.920 + 0.142ht - 0.0009ht^2)
$$

```{r}
s_z <- function(z) {
  coefs <- fixef(me_surv2)
  linear.p <- coefs[1] + coefs[2]*z + coefs[3]*z^2
  p <- 1/(1+exp(-linear.p))
  return(as.numeric(p))
}
```


# Fecundity kernel

p_b(z)b(z)p_rc_0(z^\prime)

```{r}
F_z1z <- function(z1, z) {
  return(p_bz(z) * b_z(z) * p_r * c_0z1(z1))
}
```

# Survival kernel

s(z)G(z, z^\prime)

```{r}
P_z1z <- function(z1, z) {
  return(s_z(z) * G_z1z(z, z1))
}
```


# Run IPM

## Decide meshpoints

```{r}
range(km41$ht[km41$ht>0], na.rm = TRUE)
```

So I'll go from 0.4 to 200??

```{r}
hist(km41$ht[km41$ht>0])
```
## Projection matrix

```{r}
mk_K <- function(m, L, U) {

	# mesh points 
	h <- (U - L)/m
	meshpts <- L + ((1:m) - 1/2) * h
	P <- h * (outer(meshpts, meshpts, P_z1z))
	F <- h * (outer(meshpts, meshpts, F_z1z))
	K <- P + F
	return(list(K = K, meshpts = meshpts, P = P, F = F))
}
```


```{r}
out <- mk_K(100, 0.4, 200)
```

# Results

```{r}
lambda(out$K)
plot(out$meshpts, stable.stage(out$K), type = "l")
```

```{r}
hist(km41$ht)
```
Kinda matches?

```{r}
sens <- sensitivity(out$K)

rownames(sens) <- out$meshpts
colnames(sens) <- out$meshpts
matplot2(sens)
```

Can't remember how to interpret this
